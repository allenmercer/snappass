trigger:
  - main
pr: none

variables:
  ACR_NAME: 'ailevate'
  IMAGE_NAME: 'echo'
  IMAGE_TAG: '$(Build.BuildId)'
  VM_IMAGE: 'ubuntu-latest'

stages:
  ############################################################
  ### Stage to Build Docker Image                          ###
  ############################################################
- stage: BuildAndPush
  displayName: 'Build and Push Docker Image'
  jobs:
  - job: BuildAndPushJob
    displayName: 'Build and Push'
    pool:
      vmImage: $(VM_IMAGE)
    steps:
    - checkout: self
      
    - script: git clone --depth 1 https://github.com/pinterest/snappass.git source
      displayName: 'Clone Official Snappass Repo'

    - script: |
        echo "Applying Ailevate customizations..."
        
        # Create a directory for images
        mkdir -p source/snappass/static/img

        # Copy the logo, background, stylesheet, and all HTML templates
        cp -Rv customizations/img/* source/snappass/static/img/
        cat customizations/css/custom.css >> source/snappass/static/snappass/css/custom.css
        cp -Rv customizations/templates/* source/snappass/templates/
        
        # Replace the SnapPass text in set_password
        # This is one of two places where the end user would see the word SnapPass.
        # The second place is the Redis prefix.
        sed -i 's/SnapPass/Ailevate Echo/g' source/snappass/templates/set_password.html

        # Replace all instances of the word snappass or snap pass, case insensitive, from any template to prevent leakage.
        sed -i '/STATIC_URL/! s/snappass/ailevateecho/I' source/snappass/templates/*
        sed -i '/STATIC_URL/! s/snap pass/ailevate echo/I' source/snappass/templates/*
      displayName: 'Apply Custom Templates, Styles, & Assets'

    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        command: buildAndPush # CHANGED: Using the combined command
        containerRegistry: '$(ACR_SERVICE_CONNECTION)'
        repository: '$(IMAGE_NAME)'
        dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
        tags: '$(IMAGE_TAG)'
        buildContext: 'source'
    
    - task: CopyFiles@2
      displayName: 'Copy Terraform Manifests'
      inputs:
        SourceFolder: '$(System.DefaultWorkingDirectory)/resource/terraform-manifests'
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/terraform'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Terraform Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/terraform'
        ArtifactName: 'terraform-manifests'

############################################################
### Stage to Deploy Azure Infrastructure                 ###
############################################################
- stage: deployAzureInfrastructure
  displayName: 'Deploy Azure Infrastructure'
  dependsOn: BuildAndPush # CHANGED: Depends on the new combined stage
  jobs:
  - deployment: deployAzureInfrastructure
    displayName: 'Deploy Azure Infrastructure'
    pool:
      name: 'global-aks'
    environment: '$(AZURE_PROJECT_NAME)'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - download: current
            artifact: terraform-manifests
          
          - task: ReplaceTokens@6
            displayName: 'Replace Terraform Variables'
            inputs:
              targetFiles: '$(Pipeline.Workspace)/terraform-manifests/*.tf'
              tokenPattern: custom
              tokenPrefix: '<-'
              tokenSuffix: '->'

          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                fi
                echo $(ls -al)

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(Pipeline.Workspace)/terraform-manifests'
              backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
              backendAzureRmResourceGroupName: '$(TERRAFORM_BACKEND_RG)'
              backendAzureRmStorageAccountName: '$(TERRAFORM_BACKEND_SA)'
              backendAzureRmContainerName: '$(TERRAFORM_BACKEND_CONTAINER)'
              backendAzureRmKey: '$(AZURE_PROJECT_NAME).tfstate'

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(Pipeline.Workspace)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: '-out create-$(Build.BuildId).plan'

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(Pipeline.Workspace)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: 'create-$(Build.BuildId).plan'

          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                fi
