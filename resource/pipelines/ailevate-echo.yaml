trigger: none
pr: none

parameters:
- name: action
  displayName: What do you want to run?
  type: string
  default: restore
  values:
  - restore     # run stages 1â€“3
  - destroy     # run stage 4 only

variables:
  ACR_NAME: 'ailevate'
  IMAGE_NAME: 'echo'
  IMAGE_TAG: '$(Build.BuildId)'
  VM_IMAGE: 'ubuntu-latest'

stages:
  ############################################################
  ### Stage to Build Docker Image                          ###
  ############################################################
- stage: BuildAndPush
  displayName: 'Build and Push Docker Image'
  condition: eq('${{ parameters.action }}','restore')
  jobs:
  - job: BuildAndPushJob
    displayName: 'Build and Push'
    pool:
      vmImage: $(VM_IMAGE)
    steps:
    - checkout: self
      
    - script: git clone --depth 1 https://github.com/pinterest/snappass.git source
      displayName: 'Clone Official Snappass Repo'

    - script: |
        echo "Applying Ailevate customizations..."
        
        # Create a directory for images
        mkdir -p source/snappass/static/img

        # Copy the logo, background, stylesheet, and all HTML templates
        cp -Rv customizations/img/* source/snappass/static/img/
        cat customizations/css/custom.css >> source/snappass/static/snappass/css/custom.css
        cp -Rv customizations/templates/* source/snappass/templates/
        
        # Replace the SnapPass text in set_password
        # This is one of two places where the end user would see the word SnapPass.
        # The second place is the Redis prefix.
        sed -i 's/SnapPass/Ailevate Echo/g' source/snappass/templates/set_password.html

        # Replace all instances of the word snappass or snap pass, case insensitive, from any template to prevent leakage.
        sed -i '/STATIC_URL/! s/snappass/ailevateecho/I' source/snappass/templates/*
        sed -i '/STATIC_URL/! s/snap pass/ailevate echo/I' source/snappass/templates/*
      displayName: 'Apply Custom Templates, Styles, & Assets'

    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        command: buildAndPush # CHANGED: Using the combined command
        containerRegistry: '$(ACR_SERVICE_CONNECTION)'
        repository: '$(IMAGE_NAME)'
        dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
        tags: 'latest' # '$(IMAGE_TAG)'
        buildContext: 'source'
    
    #- task: CopyFiles@2
    #  displayName: 'Copy Terraform Manifests'
    #  inputs:
    #    SourceFolder: '$(System.DefaultWorkingDirectory)/resource/terraform-manifests'
    #    Contents: '**'
    #    TargetFolder: '$(Build.ArtifactStagingDirectory)/terraform'
    #
    #- task: PublishBuildArtifacts@1
    #  displayName: 'Publish Terraform Artifact'
    #  inputs:
    #    PathtoPublish: '$(Build.ArtifactStagingDirectory)/terraform'
    #    ArtifactName: 'terraform-manifests'

############################################################
### Stage to Deploy Azure Infrastructure                 ###
############################################################
- stage: deployAzureInfrastructure
  displayName: 'Deploy Azure Infrastructure'
  condition: eq('${{ parameters.action }}','restore')
  #dependsOn: BuildAndPush # CHANGED: Depends on the new combined stage
  jobs:
  - deployment: deployAzureInfrastructure
    displayName: 'Deploy Azure Infrastructure'
    pool:
      name: 'global-aks'
    environment: 'allen-playground01' # FIX
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          #- download: current
          #  artifact: terraform-manifests
          
          - task: ReplaceTokens@6
            displayName: 'Replace Terraform Variables'
            inputs:
              targetFiles: '$(REPO_MANIFEST_FOLDER)/terraform-manifests/*.tf'
              tokenPattern: custom
              tokenPrefix: '<-'
              tokenSuffix: '->'

          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                fi

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              commandOptions: '-reconfigure'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
              backendAzureRmResourceGroupName: '$(TERRAFORM_BACKEND_RG)'
              backendAzureRmStorageAccountName: '$(TERRAFORM_BACKEND_SA)'
              backendAzureRmContainerName: '$(TERRAFORM_BACKEND_CONTAINER)'
              backendAzureRmKey: '$(AZURE_PROJECT_NAME).tfstate'

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: '-var="image_tag=$(Build.BuildId)" -out create-$(Build.BuildId).plan'

          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: 'create-$(Build.BuildId).plan'

          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                  PRINCIPAL_ID=$(az webapp identity show -g allen-playground01 -n echopgab-lwa --query principalId --output tsv)
                  REGISTRY_ID=$(az acr show -g sre-store -n ailevate --query id --output tsv)
                  az role assignment create --assignee $PRINCIPAL_ID --scope $REGISTRY_ID --role "AcrPull"
                fi
          - task: AzureCLI@2
            displayName: 'Generate and Store Secrets in Key Vault'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                KEY_VAULT_NAME="$(AZURE_PROJECT_NAME)-kv"
                REDIS_NAME="$(AZURE_PROJECT_NAME)-redis"
                SECRET_KEY_NAME="ECHO-SECRET-KEY"
                REDIS_KEY_NAME="REDIS-URL-FULL"
                REDIS_HOST="$(AZURE_PROJECT_NAME)-redis.redis.cache.windows.net"

                if az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "$SECRET_KEY_NAME" &>/dev/null; then
                  echo "Secret '$SECRET_KEY_NAME' already exists."
                else
                  echo "Generating and storing secret: $SECRET_KEY_NAME"
                  SECRET_VALUE=$(openssl rand -base64 64)
                  az keyvault secret set --vault-name "$KEY_VAULT_NAME" --name "$SECRET_KEY_NAME" --value "$SECRET_VALUE"
                fi
                
                echo "Retrieving Redis Primary Key and storing in Key Vault."
                REDIS_KEY=$(az redis list-keys --name "$REDIS_NAME" --resource-group "$(AZURE_RG_NAME)" --query "primaryKey" -o tsv)
                REDIS_URL_FULL="rediss://default:${REDIS_KEY}@${REDIS_HOST}:6380/0"
                az keyvault secret set --vault-name "$KEY_VAULT_NAME" --name "$REDIS_KEY_NAME" --value "$REDIS_URL_FULL"

          - task: AzureCLI@2
            displayName: 'Set Final Application Settings'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                APP_NAME="$(AZURE_PROJECT_NAME)-lwa"
                KV_NAME="$(AZURE_PROJECT_NAME)-kv"
                #REDIS_HOST="$(AZURE_PROJECT_NAME)-redis.redis.cache.windows.net"

                SECRET_KEY_URI=$(az keyvault secret show --vault-name $KV_NAME --name "ECHO-SECRET-KEY" --query "id" -o tsv)
                #REDIS_KEY_URI=$(az keyvault secret show --vault-name $KV_NAME --name "REDIS-ACCESS-KEY" --query "id" -o tsv)
                REDIS_URL_FULL_URI=$(az keyvault secret show --vault-name $KV_NAME --name "REDIS-URL-FULL" --query "id" -o tsv)

                #REDIS_URL_SETTING="redis://:@Microsoft.KeyVault(SecretUri=${REDIS_KEY_URI})@${REDIS_HOST}:6380"
                #REDIS_URL_SETTING="rediss://default:@Microsoft.KeyVault(SecretUri=${REDIS_KEY_URI})@${REDIS_HOST}:6380/0"

                echo "Updating App Service Application Settings..."
                az webapp config appsettings set -g "$(AZURE_RG_NAME)" -n "$APP_NAME" --settings \
                  "SECRET_KEY=@Microsoft.KeyVault(SecretUri=${SECRET_KEY_URI})" \
                  "REDIS_URL=@Microsoft.KeyVault(SecretUri=${REDIS_URL_FULL_URI})" \
                  "WEBSITES_PORT=5000" \
                  "REDIS_PREFIX=echo" \
                  "DEBUG=false" \
                  "NO_SSL=false" \
                  "SNAPPASS_PORT=5000"
                  # Change REDIS_PREFIX to AZURE_PROJECT_NAME


############################################################
### Stage to Destroy Azure Infrastructure                ###
############################################################
- stage: destroyAzureInfrastructure
  displayName: 'Destroy Azure Infrastructure'
  trigger: manual
  jobs:
    ### Job to Destroy Azure Infrastructure ###
    - deployment: destroyAzureInfrastructure
      displayName: 'Destory Azure Infrastructure'
      pool:
        name: 'global-aks'
      workspace:
        clean: all
      # This is the environment in ADO where the results of this job will be displayed.
      environment: 'allen-playground01'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
              #- download: current
              #  artifact: terraform-manifests
              
              - task: ReplaceTokens@6
                displayName: 'Replace Terraform Variables'
                inputs:
                  targetFiles: '$(REPO_MANIFEST_FOLDER)/terraform-manifests/*.tf'
                  tokenPattern: custom
                  tokenPrefix: '<-'
                  tokenSuffix: '->'

              ### Task to Run Terraform Init
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Init'
                #retryCountOnTaskFailure: 3
                inputs:
                  provider: 'azurerm'
                  command: 'init'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  backendAzureRmResourceGroupName: '$(TERRAFORM_BACKEND_RG)'
                  backendAzureRmStorageAccountName: '$(TERRAFORM_BACKEND_SA)'
                  backendAzureRmContainerName: '$(TERRAFORM_BACKEND_CONTAINER)'
                  backendAzureRmKey: '$(AZURE_PROJECT_NAME).tfstate'
                  
              ### Task to Run Terraform Plan Destroy
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Plan Destroy'
                inputs:
                  command: 'plan'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
                  commandOptions: '-destroy -out destroy-$(Build.BuildId).plan'
              ### Task to Run Terraform Apply Destroy
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Apply Destory'
                inputs:
                  command: 'apply'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
                  commandOptions: 'destroy-$(Build.BuildId).plan'