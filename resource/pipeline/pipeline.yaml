trigger: none
  #- main
pr: none

variables:
  IMAGE_TAG: '$(Build.BuildId)'
  VM_IMAGE: 'ubuntu-latest'

stages:
  ############################################################
  ### Stage to Build and Push Docker Image                 ###
  ############################################################
- stage: BuildAndPush
  displayName: 'Build and Push Docker Image'
  jobs:
    ### Job to Build and Push ###
    - deployment: BuildAndPushJob
      displayName: 'Build and Push'
      pool:
        vmImage: $(VM_IMAGE)
      workspace:
        clean: all
      environment: '$(AZURE_RG_NAME)'
      strategy:
        runOnce:
          deploy:
            steps:
            ### Task to Checkout GitHub Repository
            - checkout: self
            
            ### Task to Clone Official Snappass Repo
            - script: git clone --branch v1.6.2 --depth 1 https://github.com/pinterest/snappass.git source
              displayName: 'Clone Official Snappass Repo'

            ### Task to Apply Branding
            - script: |
                echo "Applying Ailevate customizations..."
                
                # Create folders for custom static content
                mkdir -p source/snappass/static/img
                mkdir -p source/snappass/static/css
                mkdir -p source/snappass/static/scripts

                # Copy the logo, background, stylesheet, HTML templates, and scripts
                cp -Rv customizations/img/* source/snappass/static/img/
                cp customizations/css/custom.css source/snappass/static/css/custom.css
                cp -Rv customizations/templates/* source/snappass/templates/
                cp -Rv source/snappass/static/snappass/scripts/* source/snappass/static/scripts
                
                # Replace the SnapPass text in set_password
                sed -i 's/SnapPass/Ailevate Secret Sharing Service/g' source/snappass/templates/set_password.html

                # Replace "/snappass" for script paths in templates
                sed -i 's~/snappass~~' source/snappass/templates/*

                # Replace all instances of the word snappass or snap pass, case insensitive, from any template to prevent leakage.
                sed -i 's/snappass/Ailevate Secret Sharing Service/I' source/snappass/templates/*
                sed -i 's/snap pass/Ailevate Secret Sharing Service/I' source/snappass/templates/*
              displayName: 'Apply Branding'

            ### Task to Build and Push Docker Image
            - task: Docker@2
              displayName: 'Build and Push Docker Image'
              inputs:
                command: buildAndPush # CHANGED: Using the combined command
                containerRegistry: '$(ACR_SERVICE_CONNECTION)'
                repository: '$(IMAGE_NAME)'
                dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
                tags: 'latest' # '$(IMAGE_TAG)'
                buildContext: 'source'


############################################################
### Stage to Deploy Azure Infrastructure                 ###
############################################################
- stage: deployAzureInfrastructure
  displayName: 'Deploy Azure Infrastructure'
  jobs:
  - deployment: deployAzureInfrastructure
    displayName: 'Deploy Azure Infrastructure'
    pool:
      name: 'global-aks'
    environment: '$(AZURE_RG_NAME)'
    strategy:
      runOnce:
        deploy:
          steps:
          ### Task to Checkout GitHub Repository
          - checkout: self
          ### Task to Replace Tokens
          - task: ReplaceTokens@6
            displayName: 'Replace Terraform Variables'
            inputs:
              targetFiles: '$(REPO_MANIFEST_FOLDER)/terraform-manifests/*.tf'
              tokenPattern: custom
              tokenPrefix: '<-'
              tokenSuffix: '->'
          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                fi
          ### Task to Bootstrap RG, Key Vault, and Permissions
          - task: AzureCLI@2
            displayName: 'Bootstrap RG, Key Vault, and Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                KEY_VAULT_NAME="$(AZURE_RG_NAME)-kv"

                # This command does not need tags; Terraform will add them.
                echo "Ensuring Resource Group '$(AZURE_RG_NAME)' exists..."
                az group create --name "$AZURE_RG_NAME" --location "$AZURE_RG_LOCATION" \
                --tags workloadtier='$(TAG_REQUIRED_WORKLOADTIER)' customer='$(TAG_REQUIRED_CUSTOMER)' environment='$(AZURE_PROJECT_LE)' workload='$(AZURE_RG_NAME)'

                echo "Ensuring Key Vault '$KEY_VAULT_NAME' exists with tags..."
                if az keyvault show --name "$KEY_VAULT_NAME" --resource-group "$(AZURE_RG_NAME)" &>/dev/null; then
                  echo "Key Vault '$KEY_VAULT_NAME' already exists. Skipping creation."
                else
                  echo "Key Vault '$KEY_VAULT_NAME' not found. Creating..."
                  az keyvault create --name "$KEY_VAULT_NAME" --resource-group "$(AZURE_RG_NAME)" --location "$(AZURE_RG_LOCATION)" --retention-days 7 --enable-rbac-authorization false \
                    --tags workloadtier='$(TAG_REQUIRED_WORKLOADTIER)' customer='$(TAG_REQUIRED_CUSTOMER)' environment='$(AZURE_PROJECT_LE)' workload='$(AZURE_RG_NAME)'
                fi

                echo "Granting pipeline secret permissions on Key Vault..."
                # 1. Get the Application (Client) ID of the currently logged-in Service Principal
                SP_APP_ID=$(az account show --query "user.name" -o tsv)
                echo "Found Application ID for pipeline: $SP_APP_ID"
                # 2. Use the Application ID to look up the Service Principal's unique Object ID
                PIPELINE_SP_ID=$(az ad sp show --id $SP_APP_ID --query "id" -o tsv)
                echo "Found Object ID for pipeline: $PIPELINE_SP_ID"
                # 3. Assign the policy using the reliably-found Object ID
                az keyvault set-policy --name "$KEY_VAULT_NAME" --object-id "$PIPELINE_SP_ID" --secret-permissions get list set delete purge --output none
          ### Task to Run Terraform Init
          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              commandOptions: '-reconfigure'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
              backendAzureRmResourceGroupName: '$(TERRAFORM_BACKEND_RG)'
              backendAzureRmStorageAccountName: '$(TERRAFORM_BACKEND_SA)'
              backendAzureRmContainerName: '$(TERRAFORM_BACKEND_CONTAINER)'
              backendAzureRmKey: '$(AZURE_RG_NAME).tfstate'
          ### Task to Run Terraform Plan
          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: '-var="image_tag=$(Build.BuildId)" -out create-$(Build.BuildId).plan'
          ### Task to Run Terraform Apply
          - task: TerraformTaskV4@4
            displayName: 'Run Terrafrom Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
              environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
              commandOptions: 'create-$(Build.BuildId).plan'
          ### Task to Assign Resource Group Permissions
          - task: AzureCLI@2
            displayName: 'Assign Resource Group Permissions'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Fail if any command fails
                set -e
                if $(az group exists --name "$AZURE_RG_NAME") .eq "true"; then
                  # Get Role Assignment Status
                  RG_ROLE_ASSIGNMENT=$(az role assignment list --resource-group "$AZURE_RG_NAME" --query "[?principalId=='ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0' && roleDefinitionName=='Owner'].roleDefinitionName" -o tsv)
                  # If Resource Group permissions do not exist...
                  if [[ "$RG_ROLE_ASSIGNMENT" != "Owner" ]]; then
                    echo "Adding role assignment..."
                    AZURE_RG_ID=$(az group show --name  $AZURE_RG_NAME | jq -r  '.id')
                    az role assignment create --assignee-object-id ec55e7d4-ae11-4c67-a7bf-ce9c0085bbd0 --assignee-principal-type User --role Owner --scope $AZURE_RG_ID
                  else
                    echo "Role assignment already exists."
                  fi
                fi
          ### Task to Restart App Service
          - task: AzureCLI@2
            displayName: 'Restart App Service'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_SPN)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Restarting App Service '$(AZURE_RG_NAME)-ailwa' to force a pull of the :latest image..."
                az webapp restart --name "$(AZURE_RG_NAME)-ailwa" --resource-group "$(AZURE_RG_NAME)"


############################################################
### Stage to Destroy Azure Infrastructure                ###
############################################################
- stage: destroyAzureInfrastructure
  displayName: 'Destroy Azure Infrastructure'
  trigger: manual
  jobs:
    ### Job to Destroy Azure Infrastructure ###
    - deployment: destroyAzureInfrastructure
      displayName: 'Destory Azure Infrastructure'
      pool:
        name: 'global-aks'
      workspace:
        clean: all
      # This is the environment in ADO where the results of this job will be displayed.
      environment: 'allen-playground01'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
              #- download: current
              #  artifact: terraform-manifests
              
              - task: ReplaceTokens@6
                displayName: 'Replace Terraform Variables'
                inputs:
                  targetFiles: '$(REPO_MANIFEST_FOLDER)/terraform-manifests/*.tf'
                  tokenPattern: custom
                  tokenPrefix: '<-'
                  tokenSuffix: '->'

              ### Task to Run Terraform Init
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Init'
                #retryCountOnTaskFailure: 3
                inputs:
                  provider: 'azurerm'
                  command: 'init'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  backendAzureRmResourceGroupName: '$(TERRAFORM_BACKEND_RG)'
                  backendAzureRmStorageAccountName: '$(TERRAFORM_BACKEND_SA)'
                  backendAzureRmContainerName: '$(TERRAFORM_BACKEND_CONTAINER)'
                  backendAzureRmKey: '$(AZURE_PROJECT_NAME).tfstate'
                  
              ### Task to Run Terraform Plan Destroy
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Plan Destroy'
                inputs:
                  command: 'plan'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
                  commandOptions: '-destroy -out destroy-$(Build.BuildId).plan'
              ### Task to Run Terraform Apply Destroy
              - task: TerraformTaskV4@4
                displayName: 'Run Terrafrom Apply Destory'
                inputs:
                  command: 'apply'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/$(REPO_MANIFEST_FOLDER)/terraform-manifests'
                  backendServiceArm: '$(TERRAFORM_BACKEND_SPN)'
                  environmentServiceNameAzureRM: '$(AZURE_SERVICE_SPN)'
                  commandOptions: 'destroy-$(Build.BuildId).plan'
              - task: AzureCLI@2
                displayName: 'Delete Bootstrap Resources (Key Vault and RG)'
                inputs:
                  azureSubscription: '$(AZURE_SERVICE_SPN)'
                  scriptType: 'bash'
                  scriptLocation: 'inlineScript'
                  inlineScript: |
                    set -e

                    if [ "$(az group exists --name '$(AZURE_RG_NAME)')" = "true" ]; then
                      KEY_VAULT_NAME="$(AZURE_PROJECT_NAME)-kv"
                      echo "Purging and deleting Key Vault '$KEY_VAULT_NAME'..."
                      # Delete the Key Vault first
                      az keyvault delete --name "$KEY_VAULT_NAME" --resource-group "$(AZURE_RG_NAME)"
                      # Now purge it from the soft-deleted state
                      az keyvault purge --name "$KEY_VAULT_NAME"

                      echo "Deleting Resource Group '$(AZURE_RG_NAME)'..."
                      az group delete --name "$(AZURE_RG_NAME)" --yes --no-wait
                    else
                      echo "Resource group '$(AZURE_RG_NAME)' not found, nothing to delete."
                    fi